#!/usr/bin/env bash
#
# Hyprland per window xkb layout
#
# How it works:
#
# At script's launch every window (if any) gets its defined layout as currently selected.
#
# When new windows is opened the current layout is used.
# When existing window is selected - its defined layout is used.

set -e

print_debug() {
	if $DEBUG; then
		echo -e "LOG:" "$@"	
	fi
}

echons() {
	echo "$1"
	notify-send "Hyprland per window xkblayout:" "$1"
}

switch_keyboards() {
	local index="$1"
	local blacklist_mask='^(video-|power-|sleep-|yubico-|integrated-camera|intel-hid-event)'
	hyprctl devices -j | gojq -r ".keyboards | .[] | .name" |
		grep -vP "$blacklist_mask" |
		xargs -I {} hyprctl switchxkblayout "{}" "$index"
}

DEBUG="${HPWX_DEBUG:-false}"
declare -A layouts_short

#
# -------------------------------------------------------
#

kb_json=$(hyprctl devices -j)
keyboard="$(echo "$kb_json" | gojq -r ".keyboards | .[0] | .name")"

if [[ "$keyboard" == "" ]]; then
		echons "No keyboard detected"
		exit 1
fi

layout_long="$(echo "$kb_json" |
	gojq -r ".keyboards | .[0] | .active_keymap")"

# get layouts list from the 1-st keyboard device
layouts=$(echo "$kb_json" | gojq -r ".keyboards | .[0] | .layout")

# read layouts to an array
read -r -a kb_layout_arr <<< $(echo "$layouts" | tr ',' ' ')
# short layout names to index
declare -A kb_layout
for index in "${!kb_layout_arr[@]}"; do
	# inverse
	short_name="${kb_layout_arr["$index"]}"
	kb_layout["$short_name"]="$index"
		hyprctl switchxkblayout "$keyboard" "$index"
		long_name="$(hyprctl devices -j |
				gojq -r ".keyboards | .[0] | .active_keymap")"
		layouts_short["$long_name"]="$short_name"
		print_debug "found layout: '$short_name' ($index) is '$long_name'"
done

layout="${layouts_short["$layout_long"]}"

index="${kb_layout[$layout]}"
hyprctl switchxkblayout "$keyboard" "$index"

# addr to layout map
declare -A windows

# predefine current layout for all windows
for addr in $(hyprctl clients -j | gojq -r '.[] | .address'); do
	windows[$addr]="$layout"
	print_debug "define window $addr layout as '$layout'"
done

# to ignore `activelayout` events generated by script itself
from_script=false

handle() {
	event="${1%%>>*}"
	event_data="${1##*>>}"

	if $DEBUG; then
		echo "$1"
	fi

	case "$event" in
	activelayout)
		local current="$(hyprctl activewindow -j | gojq -r '.address')"
		local layout_fullname="${event_data#*,}"

		if ! [[ -v layouts_short["$layout_fullname"] ]]; then
			# layout can also be `error` or `none`
			# happens after using `wtype`
			return
		fi

		layout="${layouts_short["$layout_fullname"]}"

		if [[ "$current" == null ]]; then
			return
		fi
		if $from_script; then
			from_script=false
			return
		fi

		windows["$current"]="$layout"

		print_debug "define layout for window $current as '$layout'"
		;;

	openwindow)
		local open_addr="0x${event_data%%,*}"
		windows["$open_addr"]="$layout"
		print_debug "open window $open_addr, define layout as '$layout'"
		;;

	activewindow)
		local current="$(hyprctl activewindow -j | gojq -r '.address')"

		if [[ -v windows["$current"] ]]; then
			# loading saved layout
			local short="${windows[$current]}"
			local index="${kb_layout[$short]}"

			print_debug "window $current with defined layout '$short' (current is '$layout')"

			if [[ "$layout" == "$short" ]]; then
				return
			fi

			from_script=true
			switch_keyboards "$index"

			layout="$short"
			print_debug "RESTORED layout '$short' ($index)"
		else
			print_debug "window $current without saved layout? WTF"
		fi
		;;

	closewindow)
		local close_addr="0x${event_data}"
		unset windows["$close_addr"]
		print_debug "clear window $close_addr from map"
		;;
	esac
}

print_debug "Long layout names to short names:"
print_debug "	$(declare -p layouts_short)"
print_debug "Index of a given layout in Hyprland's 'kb_layout':"
print_debug "	$(declare -p kb_layout)"

print_debug "\n...waiting for new events...\n"

hl_instance="/tmp/hypr/$HYPRLAND_INSTANCE_SIGNATURE"

socat - UNIX-CONNECT:"$hl_instance/.socket2.sock" |
	while read -r line; do
		handle "$line"
	done

